1. a0-a7存放參數，13存放在a2中
2. 在C代码中，main调用f，f调用g。而在生成的汇编中，main函数进行了内联优化处理。
    从代码li a1,12可以看出，main直接计算出了结果并储存。
3. 在0x630中。
4. 第一行代码：00000097H=00...0 0000 1001 0111B，对比指令格式，可见imm=0，dest=00001，opcode=0010111，对比汇编指令可知，auipc的操作码是0010111，ra寄存器代码是00001。这行代码将0x0左移12位（还是0x0）加到PC（当前为0x30）上并存入ra中，即ra中保存的是0x30

第2行代码：600080e7H=0110 0...0 1000 0000 1110 0111B，可见imm=0110 0000 0000，rs1=00001，funct3=000，rd=00001，opcode=1100111，rs1和rd的知识码都是00001，即都为寄存器ra。这对比jalr的标准格式有所不同，可能是此两处使用寄存器相同时，汇编中可以省略rd部分。

ra中保存的是0x30，加上0x600后为0x630，即printf的地址，执行此行代码后，将跳转到printf函数执行，并将PC+4=0X34+0X4=0X38保存到ra中，供之后返回使用。
5. 57616=0xE110，0x00646c72小端存储为72-6c-64-00，对照ASCII码表

72:r 6c:l 64:d 00:充当字符串结尾标识

因此输出为：HE110 World

若为大端存储，i应改为0x726c6400，不需改变57616
6. 原本需要两个参数，却只传入了一个，因此y=后面打印的结果取决于之前a2中保存的数据。
